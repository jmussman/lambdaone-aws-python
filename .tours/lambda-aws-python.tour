{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "Lambda AWS Python",
  "steps": [
    {
      "title": "Entry Point",
      "description": "![AWS Lambda](.assets/aws-lambda.jpg)\n\nYou have launched the Codetour to configure and run the tests for the LambdaOne AWS Python project. This codetour will explain what is the application and show you each command that is to be executed in turn in order to perform the configuration, build, and testing of the lambda.\n\nThe entry point to the lambda is the *handler* function in *lambda_function*.py*.\nThis function receives an *event** and *context* object as arguments.\nThe context is ignored; there is nothing in there that affects this function.\n\nThe entry object carries the HTTP headers, which is where the *authorization* header will carry\nthe bearer token to carry client authorization for the function.\nIf the REQUIRE= environment variable is not set, authorization is always granted.",
      "file": "lambda_function.py",
      "line": 19
    },
    {
      "title": "Import logger",
      "description": "The logger module in the project initializes logging, importing it here triggers the module code.",
      "file": "lambda_function.py",
      "line": 16
    },
    {
      "title": "Logging",
      "description": "The logger reads the logging level from the external configuration in .env, and sets up the logging to\ngo to stdout.\nMessages written to stdout are captured in the Docker container and added to the container log.",
      "file": "lambdaone/logger.py",
      "line": 99
    },
    {
      "title": "Application configuration",
      "description": "The configurable options for the lambda function are externalized to a .env file and loaded with the\n*dotenv* Python module.\nNote: This file is intended for deployment; the tests override the settings in this file.\n\n|Attribute|Description|\n|---|---|\n|AUDIENCE|This must match the *aud** claim in the OAuth access token|\n|ISSUER|This must match the *iss* claim in the access token|\n|JWKSPATH|The URL to retrieve the JWKS signing keys for a third-party IdP|\n|LAMBDA_LOG_LEVEL|DEBUG,INFO,WARN,ERROR,CRITICAL - the level to log at|\n|REQUIRE|A comma-separated list of scopes, the permissions for the caller|\n|SIGNATUREKEYPATH|The path to a local PEM file in the lambda environment|",
      "file": ".env",
      "line": 99
    },
    {
      "title": "Bearer token",
      "description": "The access token enters as a \"bearer\" token in the HTTP headers, which appear in the *event* object.\nIf the token is expected and exists, the token after \"bearer \" is stripped out of the header.",
      "file": "lambda_function.py",
      "line": 53
    },
    {
      "title": "Signing key",
      "description": "To verify the token it must have the correct claims and it must be digitally signed by the IdP.\nThere are two options for the public key to verify the signature.\nThe public key may be read by a JWKS endpoint at the IdP by the *jwt_key* module, or\nit could be statically read from a PEM file deployed with the lambda by the *fixed_key* module.",
      "file": "lambda_function.py",
      "line": 77
    },
    {
      "title": "Token verification",
      "description": "The *authz* module handles the actual verification, making sure the signature is legitimate, and the audience, issuer, and scopes (permissions) required\nare present in the token.\nThis is a two-step process: the *jwt* module is used to check the signature, audience and issuer.\nIf the contents looks OK, the scopes in the token are compared against the scopes required by the lambda to make sure the\nclient has permission to actually complete the task.",
      "file": "lambdaone/authz.py",
      "line": 30
    },
    {
      "title": "Result",
      "description": "If everything is OK, this function simply returns a Hello World! message with the version of Python the lambda is running under.\nThe message is generated by the *hello_world* module, just because we can.",
      "file": "lambda_function.py",
      "line": 87
    },
    {
      "title": "Create a Python virtual environment",
      "description": "Here begins the commands to set up the Python environment and run the lambda unit and integration tests.\nEach command is a link, all you need to do click on the command to execute it.\n\nPip needs to install the dependencies locally in a virtual environment to avoid conflicts with Python globally.\nThis command builds a virtual environment in the project space.\nClick on the command to execute it, the command will run in the terminal window:\n\n$ [python -m venv .venv](command:codetour.sendTextToTerminal?[\"python -m venv .venv\"])\n\n."
    },
    {
      "title": "Activate the virtual environment",
      "description": "The command line needs to be linked to the virtual environment so that Python runs in that space.\nVS Code has been set up so that new terminals will automatically run the activation, but the current terminal\nstill needs to be set up:\n\n$ [. ./.venv/bin/activate](command:codetour.sendTextToTerminal?[\". ./.venv/bin/activate\"])\n\n."
    },
    {
      "title": "Add dependencies",
      "description": "Click the command to add the project dependencies:\n\n$ [pip install -r requirements.txt](command:codetour.sendTextToTerminal?[\"pip install -r requirements.txt\"])\n\n.",
      "file": "requirements.txt",
      "line": 99
    },
    {
      "title": "Add development dependencies",
      "description": "Click the command to add the project dependencies:\n\n$ [pip install -r devrequirements.txt](command:codetour.sendTextToTerminal?[\"pip install -r devrequirements.txt\"])\n\n.",
      "file": "devrequirements.txt",
      "line": 99
    },
    {
      "title": "Enable container tests",
      "description": "The integration test fixture *test_lambda_function_docker* requires Docker in order to complete.\nIf you are using Codespace, Docker is already installed and running.\nIf you are using a local computer, now is the time to ensure that Docker is running.\nIf you do not have Docker, there will be four failed tests.\nThe impact will be minimal, since the tests check for Docker first.\n\n."
    },
    {
      "title": "Execute all tests with code coverage",
      "description": "This command will run the unit and integration tests with code coverage.\nThe test run will be in one terminal window, and the code coverage report will be in a second terminal window:\n\n$ [coverage run --source=lambda_function,lambdaone -m unittest discover -s test -v](command:codetour.sendTextToTerminal?[\"coverage run --source=lambda_function,lambdaone -m unittest discover -s test -v\"])\n\n."
    },
    {
      "title": "Show the code coverage report",
      "description": "This command will show the code coverage for the last test fixtures run:\n\n$ [coverage report -m](command:codetour.sendTextToTerminal?[\"coverage report -m\"])\n\n."
    },
    {
      "title": "Alternatives for running tests",
      "description": "If you open the \"Run and Debug\" panel in VS Code, there are four launch configurations defined:\n\n* All Tests\n* Coverage All Tests\n* Run Current File\n* Run Current Test File\n\nWhen you are editing the test code and want to run a file or a test, look to these configurations,\nespecially \"Run Current Test File\".\nThat one will run just the fixture you are working on in the debugger,\nwhich allows you to set breakpoints and look at what is going on."
    },
    {
      "title": "From jwt import PyJWKClient",
      "description": "Back to the *jwt_key* module - notice the syntax for importing *PyJWKClient*.\nProgrammers have options for import code from other modules:\n\n* import jwt\n* from jwt import PyJWKClient\n* import jwt.PyJWKClient as PyJWKClient\n\nIn the first form the name must be qualified to use it: *jwt.PyJWKClient()*.\nIn the second and third forms, the reference to PyJWKClient ends up in a local property of the module,\nso it can just be used as *PyJWKClient()*.\nOf course when using \"as\" the name could be changed at the same time.\n\nThis leads to problems mocking a class (or function or property) imported this way.\nIf it is a closed-box (or opaque-box) test we do not know what style the programmer is using.\nEven if we can see the code, and after all it is our unit test against our code, what if the style changes during a refactor?\nWhat if an assigned name changes?\n\nSo the solution is we have to mock the reference in *jwt* before the import, not the property (if it even exists) in this module!",
      "file": "lambdaone/jwt_key.py",
      "line": 8
    },
    {
      "title": "Hoisting the mocks for PyJWKClient, debug, and error",
      "description": "Read the description up above this section (starting a line 25).\nWhen the code under test (CUT) uses the import form \"from jwt import PyJWKClient\" for any class\nor function export the property in the CUT is set during the import, and that happens before the\ntest.\nDuring closed-box (opaque) testing, the test has no idea of what form the CUT is using.\nEven during translucent-box or clear-box testing the CUT could change the style and break the\ntest.\nIt is better to prepare for the worst and hope for the best.\n\nThe trick is to mock out the class or function, and then force a reload of the module which is ***doing\nthe import***; that forces the property in the module to be updated.\nIn this test, two class definitions in the jwt package and one function definition in the logging\nmodule need to be mocked out.\n\nThe references to the original class and function defintions are saved, and then the mocks\nare established.\nRemember, if the CUT is using the *from ... import* style the module has to be reloaded\nfor the internal property to be set to the mock.\nThis is the purpose of the *importlib.reload* call, just make sure it is the *importing* module!",
      "file": "test/unit/test_lambdaone/test_jwt_key.py",
      "line": 59
    },
    {
      "title": "Restore PyJWKClient, debug, error",
      "description": "To undo this stop the mocks that were established in the *setUpClass* method.\nThen put back the original references to the mockeded class and function that were saved in *setUpClass*.\nFinally reload the CUT module that (may have) used the *from ... import ...* style.\nThat will remove the mocks from the CUT module.\n\nAny other modules that used the style were not affected by the mocks anyways because they\nwere never reloaded.",
      "file": "test/unit/test_lambdaone/test_jwt_key.py",
      "line": 81
    },
    {
      "title": "Stop!",
      "description": "![Stop!](.assets/stop.png)\n\nThat completes the tour!\nWe have put together the project, ran the unit and integration tests, and explored how\nthe class and function mocks were hoisted above the module imports.\n\nReturn to the README.md file to learn about deployment: deploying as a container or deploying as a zip file.\n",
      "file": "test/unit/test_lambdaone/test_jwt_key.py",
      "line": 81
    }
  ]
}